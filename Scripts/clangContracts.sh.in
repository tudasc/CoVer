#!/usr/bin/env bash
set -e

POSITIONAL_ARGS=()

function ifdryrun() {
  if [[ $dryrun -eq 1 || $verbose -eq 1 ]]; then
    echo $1
  fi
  if [[ $dryrun -eq 0 ]]; then
    eval $1
  fi
}

function print_help() {
    name=$(basename $0)
    printf "$name is a compiler wrapper to utilize the LLVMContractsPlugin"
    printf "\nRequires LLVM >= @LLVM_VERSION_MIN@."
    printf "\n\nUsage: $0 [--dry-run] [--verbose] [--wrap-target <arg>] <compiler-params>"
    printf "\n\t --dry-run: Only show the commands that would be run, but do not perform any"
    printf "\n\t --wrap-target: Set the compiler to wrap around"
    printf "\n\t --verbose: Print commands to be executed"
    printf "\n\t --help: Print this help text and exit"
    printf "\n"
}

function parse_cmd() {
unset rem_args
unset compiler_bin
dryrun=0
verbose=0

while [[ $# -gt 0 ]]; do
  case $1 in
    --help)
      print_help
      exit 0
      ;;
    --dry-run)
      dryrun=1
      shift # past value
      ;;
    --verbose)
      verbose=1
      shift # past value
      ;;
    --wrap-target)
      compiler_bin="$2"
      shift # past argument
      shift # past value
      ;;
    *)
      rem_args+=( "$1" )
      shift # past argument
      ;;
  esac
done
}

parse_cmd $@

##
## Set default compiler target if needed
##
if [[ "${compiler_bin}" == "" ]]; then
  compiler_bin="@COMPILER_WRAP_EXPR@"
fi

##
## Sanity Checks
##

# Check that some form of Clang is used
compiler_name=$(${compiler_bin} --version | head -n 1)
if ! [[ "${compiler_name}" =~ .*(c|f)lang ]]; then
    printf "Compiler is unsupported! Detected: ${compiler_name}\n"
    exit 1
fi

# Check that Clang version is OK
clang_ver_detect_regex=".*(c|f)lang(\+\+)? version ([0-9]*)\..*"
clang_major=$(${compiler_bin} --version | head -n 1 | sed -rE "s/${clang_ver_detect_regex}/\3/g")
if [[ ${clang_major} -lt @LLVM_VERSION_MIN@ ]]; then
    printf "Clang version is unsupported! Minimum Required: @LLVM_VERSION_MIN@. Detected: ${clang_major}\n"
    exit 1
fi

##
## Run actual compiler stuff
##

# Get source files, and generate corresponding IR
unset SRC_FILE_PATHS
unset SRC_FILE_NAMES
unset TMP_OBJ_FILES
unset filtered_rem_args
skip_linker=0
dest_path_spec=""
opt_level_string=""
append_str=""
for (( i=0; i < ${#rem_args[@]}; i++ )); do
  cur="${rem_args[@]:$i:1}" # Weird syntax needed for bash/zsh cross compatibility
  if [[ "$cur" =~ (@COMPILE_SRC_FILE_ENDINGS@)$ ]]; then
    CUR_FILE="$cur"
    SRC_FILE_PATHS+=( "$CUR_FILE" )
    CUR_FILE="$(echo "$CUR_FILE" | sed -E 's/(@COMPILE_SRC_FILE_ENDINGS@)$//')"
    SRC_FILE_NAMES+=( "$(basename "$CUR_FILE")" )
  elif [[ "$cur" == "-o" ]]; then
    dest_path_spec="$cur ${rem_args[@]:i+1:1}"
    ((i++)) || true
  elif [[ "$cur" == "-MT" ]]; then
    append_str="$append_str $cur ${rem_args[@]:i+1:1}"
    ((i++)) || true
  elif [[ "$cur" == "-c" ]]; then
    skip_linker=1
  elif [[ "$cur" == "-E" ]]; then
    skip_linker=2
  else
    filtered_rem_args+=( "$cur" )
    if [[ "$cur" =~ -O[0123] ]]; then
      opt_level_string="$cur"
    fi
  fi
done

# Remove object files from args. They will be treated in the linker step, if executed
rem_args="${filtered_rem_args[@]}"

# Get IR for source files, if any exist
if [[ ${#SRC_FILE_PATHS[@]} -gt 0 ]]; then
  filenames="$(echo ${SRC_FILE_PATHS[@]})" # Workaround for weird expansion issue
  # Remove output flag
  tmp_rem_args="$(echo "$rem_args" | sed -E 's/(^| )-o \S+//')"
  # Do not allow non-source files yet, only in linker step.
  tmp_rem_args="$(echo "$tmp_rem_args" | sed -E 's/\S+(\.so|\.o|\.a)([\s]|$)//')"
  # Add back output flag, if no linker used
  if [[ $skip_linker -ge 1 ]]; then
    tmp_rem_args="$tmp_rem_args $dest_path_spec"
  fi
  # Use -c if mixed linker call or linker skip, use -E if only preprocessor (skip_linker=2)
  if [[ $skip_linker -lt 2 ]]; then
    tmp_rem_args="-c $tmp_rem_args"
  else
    tmp_rem_args="-E $tmp_rem_args"
  fi

  # Generate IR for source files
  ifdryrun "${compiler_bin} -g -S -emit-llvm -Xclang -disable-O0-optnone $tmp_rem_args $append_str $filenames"


  if [[ $dest_path_spec == "" ]] && [[ $skip_linker -eq 1 ]]; then
    # No output dir specified, but objects requested. Above command generated .ll instead of .o files
    for file_base in "${SRC_FILE_NAMES[@]}"; do
      # Move such that they end on .o instead
      ifdryrun "mv ${file_base}.ll ${file_base}.o"
    done
  elif [[ $skip_linker -eq 0 ]]; then
    # Linker is NOT being skipped, so generated object files are temporary. So move them to a temporary location
    for file_base in "${SRC_FILE_NAMES[@]}"; do
      tmpfile=$(mktemp --suffix=.ll)
      ifdryrun "mv ${file_base}.ll ${tmpfile}"
      TMP_OBJ_FILES+=( "${tmpfile}" )
    done
  fi
fi

# Exit early if linker unwanted
if [[ $skip_linker -ge 1 ]]; then
  exit 0
fi

##
## Link Steps
##

# Object files are those in args that end on .o, or those generated from source in earlier compile step
OBJ_FILES=( "$(echo $rem_args | tr ' ' '\n' | grep "\.o" || true)" "${TMP_OBJ_FILES[@]}" )

for OBJ_FILE in ${OBJ_FILES[@]}
do
    # remove OBJ_FILES from args
    rem_args=${rem_args//$OBJ_FILE/}
done

# Add back output flag.
# Must be after the above to make sure that if output includes .o it is not counted as required object file
rem_args="$rem_args $dest_path_spec"

tmpfile=$(mktemp --suffix=.ll)

# link together object files
ifdryrun "llvm-link -S ${OBJ_FILES[*]} -o ${tmpfile}"
ifdryrun "opt ${opt_params} -load-pass-plugin \"@CONTR_PLUGIN_PATH@\" -passes='contractVerifierPreCall,contractVerifierRW,contractPostProcess' ${tmpfile} -o ${tmpfile}.opt"
ifdryrun "llc ${opt_level_string} ${tmpfile}.opt -o ${tmpfile}.opt.o -filetype=obj --relocation-model=pic"
ifdryrun "${compiler_bin} -g $rem_args -lm -ldl -lpthread ${tmpfile}.opt.o"
