import os
import sys
import re

if len(sys.argv) < 3:
    print(f"Insufficient arguments!\nUsage: {os.path.basename(__file__)} <outpath> <shmem.h location> [identifier]")
    exit(1)

# Output filepath for header file
output_path = sys.argv[1]

# Filepath for input header
inputh_location = sys.argv[2]

ver_identifier = "Not given"
if len(sys.argv) > 3:
    ver_identifier = sys.argv[3]

# Deprecated / Ignored functions
ignorelist = [
]


function_decls = {}
function_contracts = {}

# Get all function definitions
with open(inputh_location) as f:
    h_iter = iter(f.readlines())
    for line in h_iter:
        if re.match(r"[ \tA-z0-9()\"]+ .* shmem_[\w]+[ \t]*\(.*", line):
            # Found a function definition. Get the function name
            res = re.search(r" (shmem_.*?)\(", line)
            funcname = res.group(1).strip()

            # Deprecated or otherwise ignored functions
            if any([x.lower() == funcname.lower() for x in ignorelist]):
                continue

            # Extract full function
            funcdec = line
            while True:
                if ";" in funcdec:
                    break;
                newline = next(h_iter)
                funcdec += newline

            # Cleanup

            # Remove newlines in declaration
            funcdec = funcdec.replace("\n", " ")
            # Only one space in param list
            funcdec = re.sub(",[ \t]*", ", ", funcdec)
            # Remove any postfixes
            parammatch = re.match(r".* shmem_[\w]+[ \t]*(\(.*\))", funcdec)
            if parammatch:
                funcdec = funcdec[1:parammatch.end():] + ";"
            # Remove any prefixes
            funcdec = re.sub(r".*? *(((un)?signed )?(long )?[\w*]+ shmem_[\w]+[ \t]*\(.*\))", r"\g<1>", funcdec)
            # Clear whitespace
            funcdec = funcdec.strip()

            # Add to dicts
            function_decls[funcname] = funcdec
            function_contracts[funcname] = { "PRE": [], "POST": [], "TAGS": []}

# Finally, add contracts

# Local data races
tag_buf = [("shmem_int_put_nbi", 1, "W", "R"),
           ("shmem_int_put_signal_nbi", 1, "W", "R"),
           ("shmem_int_get_nbi", 0, "RW", "W"),
           ("shmem_int_atomic_fetch_inc_nbi", 0, "RW", "RW"),
           ("shmem_int_atomic_fetch_nbi", 0, "RW", "RW"),
           ("shmem_int_atomic_compare_swap_nbi", 0, "RW", "RW"),
            ]
for func, buf_idx, forbid, action in tag_buf:
    if "R" in forbid:
        function_contracts[func]["POST"].append(f"no! (read!(*{buf_idx})) until! (called_tag!(shmem_complete))")
        function_contracts[func]["POST"].append(f"no! (called_tag!(buf_read,$:{buf_idx})) until! (called_tag!(shmem_complete))")
    if "W" in forbid:
        function_contracts[func]["POST"].append(f"no! (write!(*{buf_idx})) until! (called_tag!(shmem_complete))")
        function_contracts[func]["POST"].append(f"no! (called_tag!(buf_write,$:{buf_idx})) until! (called_tag!(shmem_complete))")
    if "R" in action:
        function_contracts[func]["TAGS"].append(f"buf_read({buf_idx})")
    if "W" in action:
        function_contracts[func]["TAGS"].append(f"buf_write({buf_idx})")

tag_shmemcomplete = [("shmem_barrier_all"), ("shmem_barrier"), ("shmem_quiet")]
for func in tag_shmemcomplete:
    function_contracts[func]["TAGS"].append(f"shmem_complete")

# Output file
boilerplate_header = f"""
// Automatically generated by {os.path.basename(__file__)}
// Instead of modifying this file, consider modifying the generation script
// Identifier: {ver_identifier}

#pragma once
#include "Contracts.h"
#include <shmem.h>

"""

header_output = boilerplate_header

def create_contract_output_for_func(types, contrs):
    out = ""
    for c_type in types:
        if not contrs[c_type]: continue
        out += f"    {c_type} {{\n"
        for c in contrs[c_type][:-1]:
            out += f"        {c},\n"
        out += f"        {contrs[c_type][-1]}\n"
        out += "    }\n"
    return out

for func, contrs in function_contracts.items():
    if not contrs["PRE"] and not contrs["POST"] and not contrs["TAGS"]:
        continue # No contracts, no need to output
    header_output += function_decls[func][:-1] + " CONTRACT(\n"
    header_output += create_contract_output_for_func(contrs.keys(), contrs)
    header_output += ");\n\n"

with open(f"{output_path}/shmem_contracts.h", "w") as contr_file:
    contr_file.write(header_output)
